/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as _moment from 'moment';
import * as i0 from "@angular/core";
/** @type {?} */
var moment = _moment;
var DatepickerService = /** @class */ (function () {
    function DatepickerService() {
        this.months = [
            { value: 1, label: 'Jan' },
            { value: 2, label: 'Feb' },
            { value: 3, label: 'Mar' },
            { value: 4, label: 'Apr' },
            { value: 5, label: 'May' },
            { value: 6, label: 'Jun' },
            { value: 7, label: 'Jul' },
            { value: 8, label: 'Aug' },
            { value: 9, label: 'Sep' },
            { value: 10, label: 'Oct' },
            { value: 11, label: 'Nov' },
            { value: 12, label: 'Dec' },
        ];
    }
    /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    DatepickerService.prototype.generateMonthDate = /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    function (month, year) {
        if (month < 10) {
            month = '0' + month;
        }
        /** @type {?} */
        var day = Number(moment(year + '-' + month + '-01T00:00:00').format('d'));
        if (day === 'Invalid date') {
            throw "Looks like something went wrong with day Generation" + arguments[0] + arguments[1];
        }
        return day;
    };
    /**
     * @return {?}
     */
    DatepickerService.prototype.getMonths = /**
     * @return {?}
     */
    function () {
        return this.months;
    };
    /**
     * @param {?} startDay
     * @param {?} lastDay
     * @return {?}
     */
    DatepickerService.prototype.dateComposer = /**
     * @param {?} startDay
     * @param {?} lastDay
     * @return {?}
     */
    function (startDay, lastDay) {
        /** @type {?} */
        var composed = [];
        /** @type {?} */
        var dayCounter = 0;
        /** @type {?} */
        var counter = 0;
        /** @type {?} */
        var dayPointer = 0;
        /** @type {?} */
        var weekObj = { 'week': [] };
        while (dayCounter <= lastDay || dayPointer <= 6) {
            counter++;
            if (dayPointer > 6) {
                dayPointer = 0;
            }
            if (startDay === dayPointer || dayCounter > 0) {
                dayCounter++;
            }
            weekObj['week'].push({
                day: (dayCounter <= lastDay && dayCounter > 0) ? dayCounter : ''
            });
            dayPointer++;
            if (dayPointer > 6) {
                composed.push(weekObj);
                weekObj = { 'week': [] };
            }
            if (counter > 50) {
                throw "While Loop exceeding the allowed limit !!!!" + arguments[0] + arguments[1];
            }
        }
        return composed;
    };
    /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    DatepickerService.prototype.getMonthDates = /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    function (month, year) {
        /** @type {?} */
        var totalDays = 0;
        month = Number(month);
        year = Number(year);
        switch (month) {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                totalDays = 31;
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                totalDays = 30;
                break;
            case 2:
                totalDays = (year % 4 == 0) ? 29 : 28;
                break;
            default:
                totalDays = 0;
                break;
        }
        return totalDays;
    };
    /**
     * @return {?}
     */
    DatepickerService.prototype.getYear = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var y = new Date();
        return y.getFullYear();
    };
    /**
     * @return {?}
     */
    DatepickerService.prototype.getYears = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var years = [];
        for (var i = 1950; i <= 2080; i++) {
            years.push(Number(i));
        }
        return years;
    };
    /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    DatepickerService.prototype.getDateFormatted = /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    function (date, format) {
        return moment(date).format(format);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    DatepickerService.prototype.getDateMoment = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return moment(date);
    };
    /**
     * @return {?}
     */
    DatepickerService.prototype.getMonth = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var y = new Date();
        /** @type {?} */
        var m = Number(y.getMonth()) + 1;
        return m;
    };
    DatepickerService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DatepickerService.ctorParameters = function () { return []; };
    /** @nocollapse */ DatepickerService.ngInjectableDef = i0.defineInjectable({ factory: function DatepickerService_Factory() { return new DatepickerService(); }, token: DatepickerService, providedIn: "root" });
    return DatepickerService;
}());
export { DatepickerService };
if (false) {
    /** @type {?} */
    DatepickerService.prototype.months;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5nbGFyLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvZGF0ZXBpY2tlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDOzs7SUFDNUIsTUFBTSxHQUFHLE9BQU87QUFFdEI7SUFtQkk7UUFkQSxXQUFNLEdBQUc7WUFDTCxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN4QixFQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN6QixFQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztZQUN6QixFQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztTQUM1QixDQUFDO0lB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bmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5jb25zdCBtb21lbnQgPSBfbW9tZW50O1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gIH0pXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlclNlcnZpY2Uge1xuXG4gICAgbW9udGhzID0gW1xuICAgICAgICB7dmFsdWU6IDEsIGxhYmVsOiAnSmFuJ30sXG4gICAgICAgIHt2YWx1ZTogMiwgbGFiZWw6ICdGZWInfSxcbiAgICAgICAge3ZhbHVlOiAzLCBsYWJlbDogJ01hcid9LFxuICAgICAgICB7dmFsdWU6IDQsIGxhYmVsOiAnQXByJ30sXG4gICAgICAgIHt2YWx1ZTogNSwgbGFiZWw6ICdNYXknfSxcbiAgICAgICAge3ZhbHVlOiA2LCBsYWJlbDogJ0p1bid9LFxuICAgICAgICB7dmFsdWU6IDcsIGxhYmVsOiAnSnVsJ30sXG4gICAgICAgIHt2YWx1ZTogOCwgbGFiZWw6ICdBdWcnfSxcbiAgICAgICAge3ZhbHVlOiA5LCBsYWJlbDogJ1NlcCd9LFxuICAgICAgICB7dmFsdWU6IDEwLCBsYWJlbDogJ09jdCd9LFxuICAgICAgICB7dmFsdWU6IDExLCBsYWJlbDogJ05vdid9LFxuICAgICAgICB7dmFsdWU6IDEyLCBsYWJlbDogJ0RlYyd9LFxuICAgIF07XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVNb250aERhdGUobW9udGgsIHllYXIpIHtcbiAgICAgICAgaWYobW9udGggPCAxMCkge1xuICAgICAgICAgICAgbW9udGggPSAnMCcrbW9udGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRheTogYW55ID0gTnVtYmVyKG1vbWVudCh5ZWFyICsgJy0nICsgIG1vbnRoICsgJy0wMVQwMDowMDowMCcpLmZvcm1hdCgnZCcpKTtcbiAgICAgICAgaWYoZGF5ID09PSAnSW52YWxpZCBkYXRlJykge1xuICAgICAgICAgICB0aHJvdyBcIkxvb2tzIGxpa2Ugc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCBkYXkgR2VuZXJhdGlvblwiICsgYXJndW1lbnRzWzBdICsgYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXk7XG4gICAgfVxuXG4gICAgZ2V0TW9udGhzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aHM7XG4gICAgfVxuXG4gICAgZGF0ZUNvbXBvc2VyKHN0YXJ0RGF5LCBsYXN0RGF5KSB7XG4gICAgICAgIGxldCBjb21wb3NlZCA9IFtdO1xuICAgICAgICBsZXQgZGF5Q291bnRlciA9IDA7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgbGV0IGRheVBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgd2Vla09iaiA9IHsnd2Vlayc6IFtdfTtcbiAgICAgICAgd2hpbGUoZGF5Q291bnRlciA8PSBsYXN0RGF5IHx8IGRheVBvaW50ZXIgPD0gNikge1xuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgICAgaWYoZGF5UG9pbnRlciA+IDYpIHtcbiAgICAgICAgICAgICAgICBkYXlQb2ludGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN0YXJ0RGF5ID09PSBkYXlQb2ludGVyIHx8IGRheUNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGF5Q291bnRlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Vla09ialsnd2VlayddLnB1c2goe1xuICAgICAgICAgICAgICAgIGRheTogKGRheUNvdW50ZXIgPD0gbGFzdERheSAmJiBkYXlDb3VudGVyID4gMCkgPyBkYXlDb3VudGVyIDogJycgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGF5UG9pbnRlcisrO1xuXG4gICAgICAgICAgICBpZihkYXlQb2ludGVyID4gNikge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VkLnB1c2god2Vla09iaik7XG4gICAgICAgICAgICAgICAgd2Vla09iaiA9IHsnd2Vlayc6IFtdfTtcbiAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY291bnRlciA+IDUwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJXaGlsZSBMb29wIGV4Y2VlZGluZyB0aGUgYWxsb3dlZCBsaW1pdCAhISEhXCIgKyBhcmd1bWVudHNbMF0gKyBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb3NlZDtcbiAgICB9XG5cbiAgICBnZXRNb250aERhdGVzKG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcikge1xuICAgICAgICBsZXQgdG90YWxEYXlzID0gMDtcbiAgICAgICAgbW9udGggPSBOdW1iZXIobW9udGgpO1xuICAgICAgICB5ZWFyID0gTnVtYmVyKHllYXIpO1xuICAgICAgICBzd2l0Y2ggKG1vbnRoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICB0b3RhbERheXMgPSAzMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgdG90YWxEYXlzID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdG90YWxEYXlzID0gKHllYXIgJSA0ID09IDApID8gMjkgOiAyODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG90YWxEYXlzID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxEYXlzXG4gICAgfVxuXG4gICAgZ2V0WWVhcigpIHtcbiAgICAgICAgbGV0IHkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4geS5nZXRGdWxsWWVhcigpO1xuICAgIH1cblxuICAgIGdldFllYXJzKCkge1xuICAgICAgICBsZXQgeWVhcnMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpID0gMTk1MDsgaSA8PSAyMDgwOyBpKyspIHtcbiAgICAgICAgICAgIHllYXJzLnB1c2goTnVtYmVyKGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcnM7XG4gICAgfVxuXG4gICAgZ2V0RGF0ZUZvcm1hdHRlZChkYXRlOiBhbnksIGZvcm1hdDogYW55KSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZ2V0RGF0ZU1vbWVudChkYXRlOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChkYXRlKTtcbiAgICB9XG5cbiAgICBnZXRNb250aCgpIHtcbiAgICAgICAgbGV0IHkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgbSA9IE51bWJlcih5LmdldE1vbnRoKCkpICsgMTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG59Il19